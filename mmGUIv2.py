#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.4 on Sat Oct 19 16:41:20 2013

import wx
import os
import urllib2 #for file downloading
from threading import Thread
import time
from proxy_class import caching_proxy
import logging
# import gettext

# begin wxGlade: extracode
# end wxGlade


class mmGUI_widget(wx.Frame):
    def __init__(self, media_data, *args, **kwds):
        self.logger = logging.getLogger('debug')
        self.logger.setLevel(logging.DEBUG)
        self.logger.debug('Initializing wxWidget')
        # begin wxGlade: mmGUI.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)

        self.data = media_data
        self.thread_dict = {}#will hold references to all threads
        #all controls holder (holds references to all buttons, inputs, etc.)
        self.controls={}

        #initialize caching proxy object
        self.caching_proxy = caching_proxy()
        self.queue = 0

        #holds controls for a single row
        one_set_of_controls = {}

        #build rows
        #search
        self.input_search = wx.TextCtrl(self, -1, "")
        self.button_search = wx.Button(self, -1, "Search")
        
        #results summary
        self.label_results = wx.StaticText(self, -1, "Found ")
        self.label_results_count = wx.StaticText(self, -1, "xx")
        self.label_results_etext = wx.StaticText(self, -1, "music tracks")
        
        #results' table header
        self.label_nr = wx.StaticText(self, -1, "#")
        self.label_title = wx.StaticText(self, -1, "Title", style=wx.ALIGN_CENTRE)
        self.label_length = wx.StaticText(self, -1, "Length", style=wx.ALIGN_CENTRE)
        self.label_holder = wx.StaticText(self, -1, "")

        #results table
        self.results_window = wx.ScrolledWindow(self, -1, style=wx.TAB_TRAVERSAL)

        for key in self.data.keys():
            one_set_of_controls['label_track_id_'+str(key)] = wx.StaticText(self.results_window, -1, str(key)+".")
            one_set_of_controls['label_track_title_'+str(key)] = wx.StaticText(self.results_window, -1, self.data[key]['title'])
            one_set_of_controls['label_track_length_'+str(key)] = wx.StaticText(self.results_window, -1, self.data[key]['duration'], style=wx.ALIGN_CENTRE)
            one_set_of_controls['dl_btn_'+str(key)] = wx.Button(self.results_window, key, "Download", style=wx.BU_EXACTFIT)
            self.controls[key] = one_set_of_controls

        self.__set_properties()
        self.__do_layout()

        #set actions for Download buttons
        for key in self.data.keys():
            self.Bind(wx.EVT_BUTTON, self.doParallelDownload, id=key)

    def __set_properties(self):
        self.logger.debug('Setting widget properties')
        # begin wxGlade: mmGUI_widget.__set_properties
        self.SetTitle("mmGUI")
        self.SetSize((400,300))

        #search
        self.input_search.SetMinSize((350, 27))
        self.button_search.SetMinSize((50, 27))

        #results' table header
        self.label_results.SetMinSize((37, 15))
        self.label_nr.SetMinSize((20, 15))
        self.label_title.SetMinSize((260, 15))
        self.label_length.SetMinSize((37, 15))
        self.label_holder.SetMinSize((60, 15))

        for key in self.controls.keys():
            self.controls[key]['label_track_id_'+str(key)].SetMinSize((20, 15))
            self.controls[key]['label_track_title_'+str(key)].SetMinSize((260, 15))
            self.controls[key]['label_track_length_'+str(key)].SetMinSize((37, 15))
        
        #results table size and scroll
        self.results_window.SetMinSize((400, 200))
        self.results_window.SetScrollRate(10, 10)
        # end wxGlade

    def __do_layout(self):
        self.logger.debug('Building wx Layout')
        # begin wxGlade: mmGUI_widget.__do_layout
        main_categories = wx.BoxSizer(wx.VERTICAL)
        sizer_1 = wx.BoxSizer(wx.VERTICAL)

        grid_sizer_3 = wx.FlexGridSizer(1, 4, 0, 0)
        grid_sizer_2 = wx.FlexGridSizer(1, 3, 0, 0)
        grid_sizer_1 = wx.FlexGridSizer(1, 2, 0, 0)
        grid_sizer_1.Add(self.input_search, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 2)
        grid_sizer_1.Add(self.button_search, 0, wx.LEFT | wx.RIGHT, 5)
        main_categories.Add(grid_sizer_1, 0, wx.LEFT | wx.TOP | wx.EXPAND, 5)
        grid_sizer_2.Add(self.label_results, 0, wx.LEFT | wx.EXPAND | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        grid_sizer_2.Add(self.label_results_count, 0, wx.EXPAND | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_2.Add(self.label_results_etext, 0, wx.EXPAND | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        main_categories.Add(grid_sizer_2, 0, wx.TOP | wx.BOTTOM | wx.EXPAND, 5)
        grid_sizer_3.Add(self.label_nr, 0, wx.LEFT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        grid_sizer_3.Add(self.label_title, 0, wx.LEFT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        grid_sizer_3.Add(self.label_length, 0, wx.LEFT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        grid_sizer_3.Add(self.label_holder, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        main_categories.Add(grid_sizer_3, 0, wx.TOP | wx.BOTTOM | wx.EXPAND, 5)
        

        #add found tracks
        for key in self.controls.keys():
            single_entry = wx.FlexGridSizer(1, 4, 0, 0)
            single_entry.Add(self.controls[key]['label_track_id_'+str(key)], 0, wx.LEFT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
            single_entry.Add(self.controls[key]['label_track_title_'+str(key)], 0, wx.LEFT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
            single_entry.Add(self.controls[key]['label_track_length_'+str(key)], 0, wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
            single_entry.Add(self.controls[key]['dl_btn_'+str(key)], 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
            sizer_1.Add(single_entry, 1, wx.EXPAND, 0)

        self.results_window.SetSizer(sizer_1)
        main_categories.Add(self.results_window, 0, wx.EXPAND, 0)
        self.SetSizer(main_categories)
        main_categories.Fit(self)
        self.Layout()
        # end wxGlade

    #custom actions
    def doDownload(self, track_id):  # wxGlade: mmGUI.<event_handler>
        self.logger.debug('Downloading track: ' + self.data[track_id]['title'])
        current_path = '/'.join(__file__.split('/')[:-1])
        downloads_path = os.path.join(current_path,'Downloads')
        
        #make directory if there's none yet
        if not os.path.exists(downloads_path):
            os.mkdir(downloads_path)

        #Disable button
        self.controls[track_id]['dl_btn_'+str(track_id)].Enable(False)

        #verify if track was not previously downloaded
        if os.path.isfile(os.path.join(downloads_path,self.data[track_id]['title']+'.mp3')):
            print 'Track available: ' + self.data[track_id]['title']
            self.logger.debug('Download canceled. Track: '+ self.data[track_id]['title'] +' already available')
        else:
            #Download and save
            cHandle = urllib2.urlopen(self.data[track_id]['dl_link'])
            print 'Downloading: ' + self.data[track_id]['title']
            music_track = cHandle.read()
            print "Download Complete! " + self.data[track_id]['title']
            cHandle.close()
            self.logger.debug('Track: ' + self.data[track_id]['title'] + ". Download complete. Writing to file.")

            fHandle = open(os.path.join(downloads_path,self.data[track_id]['title']+'.mp3'), 'wb')
            fHandle.write(music_track)
            fHandle.close()

            self.logger.debug('Track: '+self.data[track_id]['title']+' saved.')
            print 'Success!'

        #Enable button
        self.controls[track_id]['dl_btn_'+str(track_id)].Enable(True)

        self.queue -= 1
        if self.queue < 1:
            self.queue = 0
            print 'Batch complete!'
            self.logger.debug('All downloads finished')
        else:
            print self.queue, ' still in progress...'


    def doParallelDownload(self, event):
        self.logger.debug('Starting parallel download.')
        self.thread_dict[event.GetId()] = Thread(target=self.doDownload, args=(event.GetId(),))
        self.caching_proxy.addRequest(self.thread_dict[event.GetId()])
        self.queue += 1
        event.Skip()

    # def doTranslate(self, Event):
    #     self.controls = []
    #     self.lang_count += 1
    #     if self.lang_count%2 == 0:
    #         self.lang = ['en_US']
    #     else:
    #         self.lang = ['ru_RU']
    #     #initialize translation
    #     t = gettext.translation('default','locales/',self.lang)
    #     t.install()
    #     _=t.ugettext

    #     self.button_search.SetLabel(_("Search"))
    #     self.label_results.SetLabel(_("Found "))
    #     self.label_results_etext.SetLabel(_("music tracks"))
    #     self.label_title.SetLabel(_("Title"))
    #     self.label_length.SetLabel(_("Length"))

    def doRestart(self, event):  # wxGlade: mmGUI.<event_handler>
        print "Event handler `doRestart' not implemented!"
        event.Skip()

    def doClose(self, event):  # wxGlade: mmGUI.<event_handler>
        exit('Close button pressed...')
        event.Skip()

# end of class mmGUI_widget

class mmGUI(wx.App):
    def __init__(self, hz_what_ID, media_data):
        self.data = media_data
        super(mmGUI, self).__init__(hz_what_ID)

    def OnInit(self):
        wx.InitAllImageHandlers()
        mmGUI_window = mmGUI_widget(self.data, None, -1)
        self.SetTopWindow(mmGUI_window)
        mmGUI_window.Show()
        return 1

# end of class mmGUI
if __name__ == "__main__":
    data={1:'test'}
    mmGUI_instance = mmGUI(0, data)
    mmGUI_instance.MainLoop()